# 代码依赖环境参考，环境大版相同，版本更高级也可，最好一致
@vue/cli v4.5.7
creact-react-app v3.4.1
webpack v5.1.3（我用的是5.12.3）
node.js v12.17.0（我用的是14.4.0）

# 一、react脚手架 create-react-app 

# 创建项目01.react_cli
# npx create-react-app 01.react_cli

# 暴露creae-react-app 的webpack配置，注意该操作不可逆，操作后 react-scripts 命令主体也会变成 node
# npm run eject

# config-->paths.js（向外暴露出路径）
# scripts-->start.js（开发环境对应的文件）
# webpack.config.js（主要内容为对loader和plugin的配置，将来自己修改的时候可以直接在这个文件夹里面进行loader和plugin的修改）（核心）
# scripts-->build.js（生产环境对应的文件，与开发环境对应的文件差不多）

# creact-react-app 默认打包
# "build": "node scripts/build.js",

# 安装 cross-env 用来设置运行时环境变量
# npm i cross-env --dev

# 使用 cross-env 来 声明 env 中 GENERATE_SOURCEMAP 为 false, 并打包
# "build-no-sourcemap": "cross-env GENERATE_SOURCEMAP=false node scripts/build.js",

# 二、使用@vue/cli脚手架来创建vue2项目
# vue create 02.vue_cli
# 选择 Default([Vue 2] babel, eslint)

# vue没有暴露webpack配置的方法，可以通过 inspect 方法暴露出来
# vue inspect --mode=development > webpack.dev.js
# 暴露 mode development 的配置到 webpack.dev.js 文件中, 暴露开发环境配置
# vue inspect --mode=production > webpack.prod.js
# 暴露 mode production 的配置到 webpack.prod.js 文件中，暴露生成环境配置

# 创建自定义loader文件夹 03.loader
# 以为webpack会使用默认值打包，npx webpack
# 发现直接报错 [webpack-cli] Failed to load 'C:\Users\Administrator\Desktop\code\03.loader\webpack.config.js' config
# 上stack overflow看了下，打包指定配置文件 npx webpack --config=webpack.config.js
# 使用的js被加载了，友好提示要指定mode才能使用webpack5默认值
# 在配置文件中指定mode后，用npx webpack就能使用默认值打包了

# 安装loader-utils库来获取loader传入的参数
# npm i loader-utils -D
# 使用方法
# const {getOptions} = require('loader-utils')
module.exports = function(content, map, meta){
    //  调用方法获取options
    const options = getOptions(this)
    console.log(options)
    console.log(content)
    // 返回处理好的内容
    return content;
}

# 安装schema-utils库来验证传入的内容
# npm i loader-utils -D
# 引入库获取验证规则
# const {validate} = require('schema-utils')
# 创建验证文件 schema.json
{
    // 类型为对象
    "type":"object",
    // 验证的属性
    "properties":{
        // 验证name属性，string
        "name":{
            "type":"string",
            "description":"测试的属性姓名"
        }
    },
    // 是否运行添加新的属性
    "additionalProperties": true
}
# 对传入的内容进行验证
module.exports = function(content, map, meta){
    console.log('loader3')

    // 调用方法获取options
    const options = getOptions(this)
    // 打印内容
    console.log(options)
    // 校验内容是否合法
    // validate()方法传入校验规则，校验内容和loader名称
    validate(scheme, options, {
        name:'loader3'
    })
    console.log(content)
    // 返回处理好的内容
    return content;
}

# 三、自定义loader

# loader本质上是一个函数,接受3个参数，内容，map映射信息，meta元信息
# loader的执行顺序在use数组里面是从下往上执行, loader里面有一个pitch方法，use数组中pitch方法的执行顺序是从上往下执行，因此我们如果想先执行某些功能，可以先在pitch方法中定义

    module.exports.pitch = function() {
        console.log('pitch 1')
    }

# 同步loader
    //  方式一
    module.exports = function(content, map, meta){
        console.log('loader1')
        console.log(content)
        // 返回处理好的内容
        return content;
    }

    // 同步执行的另一种方式
    module.exports = function(content, map, meta){
        console.log('loader11')
        // loader中this.callback回调, 接受4个参数：错误(没有就传null), 处理后暴露的内容content, 映射关系map，元信息meta
        // 其中map,meta参数可不传，只传入error和content即可
        this.callback(null, content, map, meta)
    }

# 异步loader

    module.exports = function(content, map, meta){
        console.log('loader111')
        // 声明异步函数
        const callback = this.async();
        // 异步调用，loader111会被异步打印 
        setTimeout(() => {
            // 还是接受4个参数：错误(没有就传null), 处理后暴露的内容content, 映射关系map，元信息meta，可以省略三四参数
            callback(null, content)
        }, 1000)
    }

# 校验loader传入内容，获取option参数需要loader-utils库,获取校验规则需要schema-utils，撰写验证规则文件schema.json

    schema.json
    {
        "type":"object",
        "properties":{
            "name":{
                "type":"string",
                "description":"name属性需要传入string"
            }
        },
        "additionalProperties": true
    }

    loader3.js
    // 获取option需要loader-utils库
    const {getOptions} = require('loader-utils')
    // 引入库获取验证规则
    const {validate} = require('schema-utils')
    // 导入验证规则文件
    const scheme = require('./schema.json')

    // loader本质上是一个函数
    // 接受3个参数，内容，map映射信息，meta元信息
    module.exports = function(content, map, meta){
        console.log('loader3')

        // 调用方法获取options
        const options = getOptions(this)
        // 打印内容
        console.log(options)
        // 校验内容是否合法
        // validate()方法传入校验规则，校验内容和loader名字
        validate(scheme, options, {
            name:'loader3'
        })
        console.log(content)
        // 返回处理好的内容
        return content;
    }
    module.exports.pitch = function() {
        console.log('pitch 3')
    }

    webpack.config.js 
    const path = require('path');

    module.exports = {
        // webpack5默认有entry,output配置
        module:{
            rules:[
                {
                    // 处理.js文件
                    test:/\.js$/,
                    use:[
                    'loader1',
                    'loader2',
                    {
                        loader:'loader3',
                        options:{
                            name:'jojo',
                            age:18
                        }
                    }
                ]
                }
            ]
        },
        // 配置loader解析规则
        resolveLoader:{
            // 指定寻找包路径范围
            modules:[
                // 默认值，会从node_modules中找包
                'node_modules',
                // 添加自定义的loaders文件夹
                path.resolve(__dirname, 'loaders')
            ]
        },
        mode:'production'
    }

# 自定义babel-loader,获取option参数需要loader-utils库,获取校验规则需要schema-utils，撰写验证规则文件babelSchema.json,babel做编译需要@babel/core，引入util.promisefy方法将异步转换成promise形式

    babelSchema.json
    {
        "type":"object",
        "properties":{
            "presets":{
                "type":"array"
            }
        },
        "addtionalProhperties":true
    }

    babelLoader.js
    /* 自己写个babelLoader */
    // 获取传入的参数
    const { getOptions } = require('loader-utils')
    // 获取校验方法
    const { validate } =  require('schema-utils')
    // 获取校验文件
    const babelSchema = require('./babelSchema.json')
    // 获得babel做编译
    const babel = require('@babel/core')
    // 获取处理异步的工具函数
    const util = require('util')
    // 将普通的异步函数转换成promise方法
    // babel.transform用来编译代码，是一个普通异步方法
    // util.promisify将普通异步转换成基于promise的异步方法
    const transform = util.promisify(babel.transform)


    module.exports = function(content, map, meta){
        // 获取loader的options配置, 没有传入的话就位空对象
        const options = getOptions(this) || {}
        // 校验babel的options配置
        validate(babelSchema, options, {
            name:'Babel Loader'
        });
        // 创建一个异步loader
        const callback = this.async();
        // 使用babel编译代码
        transform(content, options)
            .then(({code, map}) => callback(null, code, map, meta))
            .catch((e) => callback(e))
    }

    webpack.config.js
    const path = require('path');

    module.exports = {
        // webpack5默认有entry,output配置
        module:{
            rules:[
                {
                    // 处理.js文件
                    test:/\.js$/,
                    /* 使用自己写的babelLoader */
                    loader:'babelLoader',
                    options:{
                        presets:[
                            '@babel/preset-env'
                        ]
                    }
                }
            ]
        },
        // 配置loader解析规则
        resolveLoader:{
            // 指定寻找包路径范围
            modules:[
                // 默认值，会从node_modules中找包
                'node_modules',
                // 添加自定义的loaders文件夹
                path.resolve(__dirname, 'loaders')
            ]
        },
        mode:'production'
    }


# 自定义plugin
# 安装tapable，使用其hooks来监听状态进行回调。
# 1.安装tapable：npm install tapable -D
# 2.初始化hooks容器
# 2.1 同步hooks，任务会依次执行:SyncHook、SyncBailHook
# 2.2 异步hooks，异步并行：AsyncParallelHook，异步串行：AsyncSeriesHook
# 3.往hooks容器中注册事件/添加回调函数
# 4.触发hooks
# 5.启动文件：node tapable.test.js

    tapable.test.js
    // 引入钩子
    const { SyncHook, SyncBailHook, AsyncParallelHook, AsyncSeriesHook } = require('tapable')

    class Lesson{
        constructor(){
            // 初始化hook容器
            this.hooks = {
                // 同步钩子,依次执行
                // SyncHook就算有返回值，也会执行全部的函数
                go: new SyncHook(['address']),
                // SyncBailHook中只有函数有返回值，就会停止执行，跳出
                see: new SyncBailHook(['age']),
                // 异步钩子
                // AsyncParallelHook,异步并行钩子，
                leave: new AsyncParallelHook(['name','sex']),
                // AsyncSeriesHook,异步并行钩子
                set: new AsyncSeriesHook(['goal','now'])
            }
        }
        tap() {
            // 往hooks容器中注册事件 / 添加回调函数
            // 会依次触发内部的同/异步函数
            this.hooks.go.tap('ningbo', (address) => {
                console.log('ningbo', address)
                return 6
            })
            this.hooks.go.tap('hangzhou', (address) => {console.log('hangzhou', address)})
        }
        start(){
            // 触发hooks,调用内部
            this.hooks.go.call('宁波')
        }
        see(){
            this.hooks.see.tap('see', (age) => {
                console.log('18',age)
                // 同步钩子遇到返回值就不会执行了，和函数一样
                return 66
            })
            this.hooks.see.tap('see', (age) => {console.log('18',age)})
        }
        goSee(){
            this.hooks.see.call(200)
        }
        leave(){
            //  AsyncParallelHook异步函数不会阻塞
            //  tapAsync写异步函数，传入必要的name, age参数外，可添加callback回调函数
            this.hooks.leave.tapAsync('leave', (name, age, callback) => {
                setTimeout(() => {
                    //  打印参数
                    console.log('leave', name, age)
                    //  执行回调函数
                    callback()
                }, 2000)
            })
            //  tapPromise写异步函数，不需要传入回调函数，但是需要返回一个promise对象
            this.hooks.leave.tapPromise('leave2', (name, age) => {
                return new Promise((resolve) => {
                    setTimeout(() => {
                        //  打印参数
                        console.log('leave2', name, age);
                        resolve()
                    }, 1000)
                })
            })
        }
        goLeave(){
            // 同步调用leave中所有的异步函数
            this.hooks.leave.callAsync('jojo',18, function(){
                // 回调函数只有等leave容器中函数触发完了，才触发
                console.log('leave容器中函数触发完了')
            })
        }
        set(){
            //  tapAsync写异步函数，传入必要的name, age参数外，可添加callback回调函数
            this.hooks.set.tapAsync('set', (goal, set, callback) => {
                setTimeout(() => {
                    //  打印参数
                    console.log('set', goal, set)
                    //  执行回调函数
                    callback()
                }, 2000)
            })
            //  tapPromise写异步函数，不需要传入回调函数，但是需要返回一个promise对象
            this.hooks.set.tapPromise('set2', (goal, set) => {
                return new Promise((resolve) => {
                    setTimeout(() => {
                        //  打印参数
                        console.log('set2', goal, set);
                        resolve()
                    }, 1000)
                })
            })
        }
        goSet(){
            // 同步调用set中所有的异步函数
            this.hooks.set.callAsync('jojo',18, function(){
                // 回调函数只有等leave容器中函数触发完了，才触发
                console.log('set容器中函数触发完了')
            })
        }
    }
    //  调用SyncHook
    // const l = new Lesson();
    // l.tap();
    // l.start();

    //  调用SyncBailHook
    // const l2 = new Lesson();
    // l2.see();
    // l2.goSee();

    //  调用AsyncParallelHook
    // const l3 = new Lesson();
    // l3.leave();
    // l3.goLeave()

    //  调用AsyncSeriesHook
    const l4 = new Lesson();
    l4.set();
    l4.goSet();

# compiler钩子，用来指定同步/异步调用函数，可以参考文档
    
    Plugin1.js
    //  用来演示compiler.hooks生命周期函数
    //  每个plugin都是一个类
    class Plugin1 {
        //  插件一般默认会调用apply方法，传入complier对象来提供钩子，进行不同生命周期状态内的处理
        apply(compiler){
            /* 绑定生命周期函数 */
            // compiler.hooks.emit 表示 complier的钩子触发了 emit时间
            // 'Plugin1' 表示绑定的钩子，一般绑定在默认钩子上
            // (compilation) => {...} , 表示要调用的回调函数， 传入的参数名 compilation ，可以参考wepack文档来获取返回调用
            // 文档地址：https://webpack.docschina.org/api/compiler-hooks/#emit
            compiler.hooks.emit.tap('Plugin1', (compilation) => {
                console.log('emit.tap Plugin1')
            })
            /* emit异步绑定, tapAsync */
            //  多传入一个异步参数cb
            //  compilier ==》 这个钩子的原本的执行时间额外增加了1秒，同时影响后续钩子的执行
            compiler.hooks.emit.tapAsync('Plugin1', (compilation, cb) => {
                //  定时器异步调用
                setTimeout(() => {
                    console.log('emit.tapAsync Plugin1')
                    cb();   //  需要调用异步参数才能执行异步
                }, 1000)
            })
            /* 也可以使用tapPromise来执行异步钩子, 没有异步参数 */
            compiler.hooks.emit.tapPromise('Plugin1', (compilation) => {
                return new Promise((resolve) => {
                    setTimeout(() => {
                        console.log('emit.tapPromise')
                        resolve()   //  成功回调让程序继续执行
                    }, 1000)
                })
            })
            /* 同理注册afterEmit */
            compiler.hooks.afterEmit.tap('Plugin1', (compilation) => {
                console.log('afterEmit.tap Plugin1')
            })
            /* 同理注册done */
            compiler.hooks.done.tap('Plugin1', (stats) => {
                console.log('done.tap Plugin1')
            })
        }
    }

    module.exports =  Plugin1;

# node 环境下使用debugger写法
# 1.写入命令，指定要调试的文件 
# scripts": {
#   "start": "node --inspect-brk ./node_modules/webpack/bin/webpack.js"
# }
# 2.在该文件要调试的地方写入debugger
# 3.使用该命令运行文件
# 4.打开浏览器，或原本打开的浏览器刷新，在浏览器菜单中点击绿色node按钮进行调试
# 5.如果要监听变量的变化，可以在打开的调试工具中Watch区域里添加要监控的变量

# compilation钩子整合输出资源
# 1.初始化compilation钩子
# 2.往要输出资源中，添加一个a.txt文件
# 3.读取b.txt中的内容，将b.txt中的内容添加到输出资源中的b.txt文件中
# 3.1 读取b.txt中的内容需要使用node的readFile模块
# 3.2  将b.txt中的内容添加到输出资源中的b.txt文件中除了使用 2 中的方法外，还有两种形式可以使用
# 3.2.1 借助RawSource
# 3.2.2 借助RawSource和emitAsset

    Plugin2.js
    //  用来演示compilation处理内容
    const fs = require('fs')
    const util = require('util')
    //  将fs.readFile方法变成基于promise风格的异步方法
    const readFile = util.promisify(fs.readFile)
    //
    const webpack = require('webpack')
    //  sources在webpack4中是一个库，在webpack5中已经整合到内部属性里了
    const {RawSource} = webpack.sources

    //  引入绝对路径
    const path = require('path')

    /*
    1. 初始化compilation钩子
    2. 往要输出资源中，添加一个a.txt文件
    3. 读取b.txt中的内容，将b.txt中的内容添加到输出资源中的b.txt文件中
        3.1 读取b.txt中的内容需要使用node的readFile模块
        3.2  将b.txt中的内容添加到输出资源中的b.txt文件中除了使用 2 中的方法外，还有两种形式可以使用
            3.2.1 借助RawSource
            3.2.2 借助RawSource和emitAsset
    */

    //  每个plugin都是一个类
    class Plugin2 {
        //  使用complier调用hooks
        apply(compiler){
            //  thisCompilation 初始化compilation
            compiler.hooks.thisCompilation.tap('Plugin2', (compilation) => {
                // debugger
                // console.log(compilation)

                //  异步添加资源,如果需要输出外部文件需要异步读取输出
                compilation.hooks.additionalAssets.tapAsync('Plugin2',async(cb) => {
                    // debugger
                    // console.log(compilation)
                    //  定义返回内容
                    const content = 'hello plugin2'
                    //  往要输出的资源中,添加一个a.txt文件,手动指定不方便
                    compilation.assets['a.txt'] = {
                        //  指定文件大小
                        size(){
                            return content.length
                        },
                        //  指定文件内容
                        source(){
                            return content
                        }
                    }
                    //  使用绝对路径来读取内容
                    const data =  await readFile(path.resolve(__dirname, 'b.txt'))
                    //  自动读取内容添加输出文件b.txt
                    compilation.assets['b.txt'] =  new RawSource(data)
                    //  调用回调执行完成
                    cb();
                })
            })
        }

    }

    module.exports =  Plugin2;

# 自定义CopyWebpackPlugin插件——将public文件夹中的文件复制到dist文件夹下面（忽略index.html文件）
# 1.创建schema.json校验文件

    schema.json
    {
        "type":"object",
        "properties":{
            "from":{
                "type":"string"
            },
            "to":{
                "type":"string"
            }
            ,
            "ignore":{
                "type":"array"
            }
        },
        "additionalProperties": false
    }

# 2.创建CopyWebpackPlugin.js插件
# 编码思路 下载schema-utils和globby：npm install globby schema-utils -D,将from中的资源复制到to中，输出出去
# （1）读取from中所有资源, 过滤掉ignore的文件
# （2）生成webpack格式的资源
# （3）添加compilation中，输出出去

# 3.在webpack.config.js

# 五、自定义webpack

# Webpack执行流程
1. 初始化 Compiler：webpack(config) 得到 Compiler 对象
2. 开始编译：调用 Compiler 对象 run 方法开始执行编译
3. 确定入口：根据配置中的 entry 找出所有的入口文件。
4. 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行编译，再找出该模块依赖的模块，递归直到所有模块被加载进来
5. 完成模块编译： 在经过第 4 步使用 Loader 编译完所有模块后，得到了每个模块被编译后的最终内容以及它们之间的依赖关系。
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表。（注意：这步是可以修改输出内容的最后机会）
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统

# 配置基本内容
# 1.创建文件夹myWebpack
# 2.创建src-->(add.js / count.js / index.js)，写入对应的js代码
# 3.创建config-->webpack.config.js写入webpack基础配置（entry和output）
# 4.创建lib文件夹，里面写webpack的主要配置
# 5.创建script-->build.js（将lib文件夹下面的myWebpack核心代码和config文件下的webpack基础配置引入并调用run()函数开始打包）
# 6为了方便启动，控制台通过输入命令 npm init -y拉取出package.json文件，修改文件中scripts部分为"build": "node ./script/build.js"表示通过在终端输入命令npm run build时会运行/script/build.js文件，在scripts中添加"debug": "node --inspect-brk ./script/build.js"表示通过在终端输入命令npm run debug时会调试/script/build.js文件中的代码，调试代码已介绍

# 使用babel解析文件
# 1.创建文件lib --> myWebpack1 --> index.js
# 2.下载对应的babel资源 @babel/parser @babel/traverse @babel/core
# 3.对应的处理思路为：读取入口文件的内容 --> 将其解析成ast抽象语法树 --> 收集依赖 --> 编译代码：将代码中浏览器不能识别的语法进行编译,AST语法变成require语法

    index.js
    const fs = require('fs');
    const path = require('path');

    const babelParser = require('@babel/parser');
    const traverse = require('@babel/traverse').default;
    const { transformFromAst } = require('@babel/core');

    function myWebpack(config) {
    return new Compiler(config);
    }

    class Compiler {
    constructor(options = {}) {
        this.options = options;
    }
    // 启动webpack打包
    run() {
        // 1. 读取入口文件内容
        // 入口文件路径
        const filePath = this.options.entry;
        const file = fs.readFileSync(filePath, 'utf-8');
        // 2. 将其解析成ast抽象语法树
        const ast = babelParser.parse(file, {
        sourceType: 'module' // 解析文件的模块化方案是 ES Module
        })
        // debugger;
        console.log(ast);

        // 获取到文件文件夹路径
        const dirname = path.dirname(filePath);

        // 定义存储依赖的容器
        const deps = {}

        // 3.收集依赖
        traverse(ast, {
        // 内部会遍历ast中program.body，判断里面语句类型
        // 如果 type：ImportDeclaration 就会触发当前函数
        ImportDeclaration({node}) {
            // 文件相对路径：'./add.js'
            const relativePath = node.source.value;
            // 生成基于入口文件的绝对路径
            const absolutePath = path.resolve(dirname, relativePath);
            // 添加依赖
            deps[relativePath] = absolutePath;
        }
        })

        console.log(deps);

        // 4.编译代码：将代码中浏览器不能识别的语法进行编译,AST语法变成require语法
        const { code } = transformFromAst(ast, null, {
        presets: ['@babel/preset-env']
        })

        console.log(code);
    }
    }

    module.exports = myWebpack;

# 模块化
# 我们开发代码过程中讲究的是模块化开发，不同功能的代码放在不同的文件中 创建myWebpack2-->parser.js（放入解析代码）/Compiler.js（放入编译代码）/index.js（主文件）

# 收集所有的依赖
# 所有代码位于myWebpack文件夹中 Compiler.js文件中build函数用于构建代码，run函数中modules通过递归遍历收集所有的依赖，depsGraph用于将依赖整理更好依赖关系图（具体的代码功能都在代码中进行了注释）

# 生成打包之后的bundle
# 生成打包之后的bundle

    const path = require('path');
    const fs = require('fs');
    const { getAst, getDeps, getCode } = require('./parser')

    class Compiler {
    constructor(options = {}) {
        // webpack配置对象
        this.options = options;
        // 所有依赖的容器
        this.modules = [];
    }
    // 启动webpack打包
    run() {
        // 入口文件路径
        const filePath = this.options.entry;
        
        // 第一次构建，得到入口文件的信息
        const fileInfo = this.build(filePath);

        this.modules.push(fileInfo);

        // 遍历所有的依赖
        this.modules.forEach((fileInfo) => {
        /**
        {
            './add.js': '/Users/xiongjian/Desktop/atguigu/code/05.myWebpack/src/add.js',
            './count.js': '/Users/xiongjian/Desktop/atguigu/code/05.myWebpack/src/count.js'
            } 
        */
        // 取出当前文件的所有依赖
        const deps = fileInfo.deps;
        // 遍历
        for (const relativePath in deps) {
            // 依赖文件的绝对路径
            const absolutePath = deps[relativePath];
            // 对依赖文件进行处理
            const fileInfo = this.build(absolutePath);
            // 将处理后的结果添加modules中，后面遍历就会遍历它了～
            this.modules.push(fileInfo);
        }
        
        })

        console.log(this.modules);

        // 将依赖整理更好依赖关系图
        /*
        {
            'index.js': {
            code: 'xxx',
            deps: { 'add.js': "xxx" }
            },
            'add.js': {
            code: 'xxx',
            deps: {}
            }
        }
        */
    const depsGraph = this.modules.reduce((graph, module) => {
        return {
        ...graph,
        [module.filePath]: {
            code: module.code,
            deps: module.deps
        }
        }
    }, {})

    console.log(depsGraph);

    this.generate(depsGraph)

    }

    // 开始构建
    build(filePath) {
        // 1. 将文件解析成ast
        const ast = getAst(filePath);
        // 2. 获取ast中所有的依赖
        const deps = getDeps(ast, filePath);
        // 3. 将ast解析成code
        const code = getCode(ast);

        return {
        // 文件路径
        filePath,
        // 当前文件的所有依赖
        deps,
        // 当前文件解析后的代码
        code
        }
    }

    // 生成输出资源
    generate(depsGraph) {

        /* index.js的代码
        "use strict";\n' +
        '\n' +
        'var _add = _interopRequireDefault(require("./add.js"));\n' +
        '\n' +
        'var _count = _interopRequireDefault(require("./count.js"));\n' +
        '\n' +
        'function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }\n' +
        '\n' +
        'console.log((0, _add["default"])(1, 2));\n' +
        'console.log((0, _count["default"])(3, 1));
        */

        const bundle = `
        (function (depsGraph) {
            // require目的：为了加载入口文件
            function require(module) {
            // 定义模块内部的require函数
            function localRequire(relativePath) {
                // 为了找到要引入模块的绝对路径，通过require加载
                return require(depsGraph[module].deps[relativePath]);
            }
            // 定义暴露对象（将来我们模块要暴露的内容）
            var exports = {};

            (function (require, exports, code) {
                eval(code);
            })(localRequire, exports, depsGraph[module].code);
            
            // 作为require函数的返回值返回出去
            // 后面的require函数能得到暴露的内容
            return exports;
            }
            // 加载入口文件
            require('${this.options.entry}');

        })(${JSON.stringify(depsGraph)})
        `
        // 生成输出文件的绝对路径
        const filePath = path.resolve(this.options.output.path, this.options.output.filename)
        // 写入文件
        fs.writeFileSync(filePath, bundle, 'utf-8');
    }
    }

    module.exports = Compiler;